# 마법사 상어와 복제
https://www.acmicpc.net/problem/23290
입력1
```text
5 1
4 3 5
1 3 5
2 4 2
2 1 6
3 4 4
4 2
```
출력1
```text
9
```
입력2
```text
5 2
4 3 5
1 3 5
2 4 2
2 1 6
3 4 4
4 2
```
출력2
```text
13
```
입력3
```text
5 3
4 3 5
1 3 5
2 4 2
2 1 6
3 4 4
4 2
```
출력3
```text
17
```
입력4
```text
5 5
4 3 5
1 3 5
2 4 2
2 1 6
3 4 4
4 2
```
출력4
```text
35
```
입력5
```text
5 26
4 3 5
1 3 5
2 4 2
2 1 6
3 4 4
4 2
```
출력5
```text
640240
```
입력6
```text
1 10
1 1 1
4 4
```
출력6
```text
26
```
입력7
```text
8 100
1 1 1
1 1 2
1 1 3
1 1 4
1 1 5
1 1 6
1 1 7
1 1 8
1 1
```
출력7
```text
8
```
입력8
```text
10 25
1 1 1
1 1 2
1 1 3
1 1 4
1 1 5
1 1 6
1 1 7
1 1 8
2 1 1
2 1 1
2 1
```
출력8
```text
574418
```

---
# 오답 노트
0. 해결 프로세스 자체에서 시간초과가 걸렸다.
   - `dead`라는 boolean 변수를 통해 물고기들을 일일이 돌리면서 살았는지 죽었는지를 체크시켰는데 그렇게 하니 오래 걸렸다.
     - 죽은 물고기 정보를 관리할 필요가 없으면 과감하게 버릴 필요가 있다.
   - 처음에는 map을 `List<Fish>[][]` 로 관리했는데 그럴 필요가 없었다.
     - 문제에서 예시로 보듯, 방향 정보만 map에 설정해도 충분하다.
     - 다만, 복제했을 때는 물고기들의 좌표와 방향 정보를 모두 동시에 갖고 있어야하므로 `Fish`라는 객체와 그것들을 담는 리스트가 필요했다.
1. 상어가 처음에 있는 자리에서 물고기를 잡아먹지 않는다는 것을 해석한 것과 방문처리를 하는 대신 이전에 왔던 방향과 현재 가는 방향이 반대방향이라면 잡아먹는 처리를 하지 않은 것은 좋았지만, 이 두 조건을 합쳐서 생각은 못했다.
    - 즉, 상하상 => 위로 올라갔을 때 물고기를 잡아먹고, 아래로 내려갔을 때 물고기를 잡아먹는 경우가 셈해야하는데, 나는 이전과 방향이 반대이므로 처음 자리를 이미 visited처리를 한 것과 마찬가지로 계산하였다.
    - 그래서 처음에 물고기를 안 잡아먹고, 다시 돌아와도 안 잡아먹는 것으로 처리를 했다.
    - 참고로 상어가 3번만 이동하기에 이렇게 visited처리가 가능했지, 4번 이상이라면 `visited[][]`를 만들어야 했을 것이다.
2. 물고기가 움직이는 경우에서 방향 정보가 1~8이기 때문에 1~8로 셈해야하는데, 0이하가 되면 +8을 해줘야하지만 나는 실수로 0미만이 되면 +8을 해줘서 올바른 동작이 나오지 않았다.
3. 상어가 어느 방향으로 가더라도 한 마리의 물고기도 잡아먹지 않았을 경우, movingTrace를 업데이트하지 못하였다.
   - maxEat이 0이 될 수도 있는데 그것을 간과했던 것이다.
   - maxEat을 -1로 하니 해결된다.
